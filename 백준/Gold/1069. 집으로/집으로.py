'''
1) 걷기만 하는 것이 빠른 경우(자명한 경우)
   - 직선 거리(= 걷기만 해서 도착하는 시간) <= T 인 경우
   - T>=D인 경우(걸음 자체가 점프보다 빠름)
   최소 도달 시간 = 직선 거리
2) 점프만 하는 것이 빠른 경우(자명한 경우)
   - 직선 거리가 D의 정수 배인 경우
   최소 도달 시간 = ((직선 거리)//D)*t
3) 걷기와 점프를 합치거나, 조건 비교 해야하는 경우(아래 세 값 중 최소값 사용)
   a. 직선 경로(점프 + 걷기)
     1) 점프로 일직선 상에서 최대한 진행 후 남은 거리 걸어서 가기
        j(점프 횟수) = (직선 거리//D), w(걷는 횟수) = (직선 거리)-j*D, 최소 도달 시간 = j*T + w
     2) 위 경우에서 점프를 한 번 더 하고 넘치는 거리 걸어서 돌아오기
        j = (직선거리//D)+1, w = j*D - (직선 거리), 최소 도달 시간 = j*T + w
   b. 직선 + 우회 경로(점프만)
     1) 점프로 최대한 진행 후 점프 두번으로 우회하기
        j = (직선 거리//D)+1, 최소 도달 시간 = j*T     
'''
input = open(0).readline

def solution():
    x,y,d,t = map(int,input().split())
    dist = round((x**2+y**2)**0.5,10) # 직선거리
    if dist <= t or t>=d : # 걷기만 하는 것이 빠른 경우
        return dist
    if not dist%d : # 점프만 하는 것이 빠른 경우
        return (dist//d)*t
    # a1 경우
    j1 = dist//d
    w1 = dist-j1*d
    # a2 경우
    j2 = dist//d + 1
    w2 = j2*d-dist
    # a3 경우
    j3 = dist//d + 1 if dist > d else 2 # dist < d 인 경우에는 무조건 처음부터 이등변 삼각형을 만들어야 하므로 2
    return min(j1*t + w1, j2*t + w2, j3*t)

if __name__ == '__main__':
    print(solution())